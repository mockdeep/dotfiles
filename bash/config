## The prompt below gets ideas from the following:
# http://briancarper.net/blog/570/git-info-in-your-zsh-prompt
# http://github.com/adamv/dotfiles/blob/master/bashrc
# http://wiki.archlinux.org/index.php/Color_Bash_Prompt
txtred='\[\e[0;31m\]' # Red
txtgrn='\[\e[0;32m\]' # Green
txtwht='\[\e[0;37m\]' # White
bldred='\[\e[1;31m\]' # Red
bldgrn='\[\e[1;32m\]' # Green
bldylw='\[\e[1;33m\]' # Yellow
bldwht='\[\e[1;37m\]' # White
end='\[\e[0m\]'    # Text Reset

function parse_git {
    branch=$(__git_ps1 "%s")
    if [[ -z $branch ]]; then
        return
    fi

    local forward="⟰"
    local behind="⟱"
    local dot="•"

    remote_pattern_ahead="# Your branch is ahead of"
    remote_pattern_behind="# Your branch is behind"
    remote_pattern_diverge="# Your branch and (.*) have diverged"

    status="$(git status 2>/dev/null)"

    state=""
    if [[ $status =~ "working directory clean" ]]; then
        state=${bldred}${dot}${end}
    else
        if [[ $status =~ "Untracked files" ]]; then
            state=${bldred}${dot}${end}
        fi
        if [[ $status =~ "Changed but not updated" ]]; then
            state=${state}${bldylw}${dot}${end}
        fi
        if [[ $status =~ "Changes to be committed" ]]; then
            state=${state}${bldylw}${dot}${end}
        fi
    fi

    direction=""
    if [[ $status =~ $remote_pattern_ahead ]]; then
        direction=${txtred}${forward}${end}
    elif [[ $status =~ $remote_pattern_behind ]]; then
        direction=${txtred}${behind}${end}
    elif [[ $status =~ $remote_pattern_diverge ]]; then
        direction=${txtred}${forward}${end}${bldgrn}${behind}${end}
    fi

    branch=${txtwht}${branch}${end}
    git_bit="${state}${bldgrn}(${end}${branch}\
${git_bit}${direction}${bldgrn})${end}"

    printf "%s" "$git_bit"
}

function set_titlebar {
    case $TERM in
        *xterm*|ansi|rxvt)
            printf "\033]0;%s\007" "$*"
            ;;
    esac
}

function set_prompt {
    git="$(parse_git)"

    fillsize=${COLUMNS}
    fill=""
    while [[ "$fillsize" -gt "0" ]]
    do
      fill="${fill}+"
      let fillsize=${fillsize}-1
    done

    PS1="${txtred}${fill}${end}\n${txtgrn}\W${end}"
    if [[ -n "$git" ]]; then
        PS1="$PS1 $git ${bldwht}\$${end} "
    else
        PS1="$PS1 ${bldwht}\$${end} "
    fi
    export PS1

    set_titlebar "$USER@${HOSTNAME%%.*} $PWD"
}

function set_terminal_colors {
    local project_name=""

    # Use git root as the project identifier if available
    local git_root
    git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    if [[ -n $git_root ]]; then
        project_name="$git_root"
    fi

    # Skip if project hasn't changed
    if [[ $project_name == "$_TERM_COLOR_PROJECT" ]]; then return; fi
    _TERM_COLOR_PROJECT="$project_name"

    if [[ -z $project_name ]]; then
        # Reset to terminal default
        printf '\e]111\a'
        return
    fi

    # Check for per-project override in .git/info/terminal-color (hex format, e.g. #1a2b3c)
    local override="$git_root/.git/info/terminal-color"
    if [[ -f $override ]]; then
        local color
        color=$(<"$override")
        color="${color#"${color%%[![:space:]]*}"}"
        color="${color%"${color##*[![:space:]]}"}"
        printf '\e]11;%s\a' "$color"
        return
    fi

    # Hash project name to get a deterministic number
    local hash
    hash=$(printf '%s' "$project_name" | cksum | cut -d' ' -f1)

    # Map hash to hue (0-359), keep saturation high, brightness low for readability
    local hue=$((hash % 360))

    # Convert HSB to RGB using integer math
    # high=46 (~18% brightness), low=5 (~2%) gives a wide spread for visible color distinction
    local r g b
    local sector=$((hue / 60))
    local remainder=$(( (hue % 60) * 255 / 60 ))

    local low=5
    local high=46
    local mid=$(( low + (high - low) * remainder / 255 ))

    case $sector in
        0) r=$high; g=$mid;  b=$low  ;;
        1) r=$(( high - (high - low) * remainder / 255 )); g=$high; b=$low ;;
        2) r=$low;  g=$high; b=$mid  ;;
        3) r=$low;  g=$(( high - (high - low) * remainder / 255 )); b=$high ;;
        4) r=$mid;  g=$low;  b=$high ;;
        5) r=$high; g=$low;  b=$(( high - (high - low) * remainder / 255 )) ;;
    esac

    printf '\e]11;#%02x%02x%02x\a' "$r" "$g" "$b"
}

function enter_directory {
    if [[ $PWD == $PREV_PWD ]]; then return; fi
    PREV_PWD=$PWD
    set_terminal_colors
}

function prompt_command {
  enter_directory
  set_prompt
}

export PROMPT_COMMAND=prompt_command
export HISTCONTROL=ignoredups
export HISTSIZE=10000
